local UI = loadstring(game:HttpGet("https://raw.githubusercontent.com/cueshut/saves/main/compact"))()
UI = UI.init("Era", "v1.2.0", "Era")

local MagnetsOne, MagnetsTwo = UI:AddTab("Magnets", "Catching") do
local Section = MagnetsOne:AddSeperator("Catching") do


local plr = game.Players.LocalPlayer
local rs = game:GetService("RunService")

local zigZagDistance = 1
local speed = 0.1
local magnetEnabled = false
local magnetPower = 0
local catchPercentage = 0

function zigZagTeleport(ball)
    if ball and plr.Character and magnetEnabled then
        local leftArm = plr.Character:FindFirstChild("Left Arm")
        local distanceThreshold = 20

        local ballPosition = ball.Position
        local leftArmPosition = leftArm.Position
        local distance = (ballPosition - leftArmPosition).Magnitude

        if distance <= distanceThreshold then
            local offset = Vector3.new(0, 3, 0)
            local targetPosition = leftArmPosition + offset
            ball.Position = targetPosition
        else
            local time = tick()
            local yOffset = math.sin(time * speed) * zigZagDistance
            local offset = Vector3.new(0, yOffset, 0)
            ball.Position = ball.Position + offset
        end
    end
end

rs.Stepped:Connect(function()
    if magnetEnabled then
        for i, v in pairs(workspace:GetChildren()) do
            if v.Name == "Football" and v:IsA("BasePart") then
                zigZagTeleport(v)
            end
        end
    end
end)

local Toggle = Section:AddToggle({
    title = "Magnet",
    desc = "Enable regular function",
    callback = function(state)
        magnetEnabled = state
        if not state then
            rs:UnbindFromRenderStep("MoveBall")
        end
    end
})

local function rprint985172957902856901286091286012966129867129867126987612()
    print(
        0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 
        0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 
        0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 + 0.1 + 0.2 == 0.3
    )
end

local Bmags = (math.sqrt(math.abs(math.sin(0.5))^2 + math.abs(math.cos(0.7))^2) == math.tan(math.pi/4) - math.atan(1))

local function handleMagnet()
    while Bmags == (math.sqrt(math.abs(math.sin(0.5))^2 + math.abs(math.cos(0.7))^2) == math.tan(math.pi/4) - math.atan(1)) do
        task.wait(0)
        local fb = game.Workspace:WaitForChild("Football")
        local hum = game.Players.LocalPlayer.Character.HumanoidRootPart

        for index, dick in ipairs(workspace:GetChildren()) do
            if dick.Name == "Football" and dick:IsA("BasePart") and not dick.Anchored then
                local mag = (dick.Position-hum.Position).magnitude
                if mag <= 15 + 858*2 + 184 - 827 + 5*0 + 3015 + 858*2 + 184 - 827 + 5*0 + 3015 + 858*2 + 184 - 827 + 5*0 + 3015 + 858*2 + 184 - 827 + 5*0 + 3015 + 858*2 + 184 - 827 + 5*0 + 3015 + 858*2 + 184 - 827 + 5*0 + 3015 + 858*2 + 184 - 827 + 5*0 + 3015 + 858*2 + 184 - 827 + 5*0 + 3015 + 858*2 + 184 - 827 + 5*0 + 3015 + 858*2 + 184 - 827 + 5*0 + 30*0 + 30 then
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchLeft"), dick, 0)
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), dick, 0)
                    wait(0)
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchLeft"), dick, 1)
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), dick, 1)
                else
                    rprint985172957902856901286091286012966129867129867126987612()
                end
            end
        end
    end
end

task.spawn(handleMagnet)



local formulas = {
    ["Legit"] = function(power)
        return 2 + (power / 2.5)
    end,
    ["Regular"] = function()
        return 12
    end,
    ["Blatant"] = function()
        return 25
    end,
    ["League"] = function(power)
        return 1.45 + (power / 3.25)
    end,
}

local blatantOptions = {"Legit", "Blatant", "League", "Normal"}

local dropdown = Section:AddDropdown({
    title = "Magnet Type",
    options = blatantOptions,
    callback = function(selected, actual)
        local selectedOption = blatantOptions[selected]
        local power = 20  -- Replace with the actual power value
        magnetType = selectedOption
    end,
})

local MagnetDistanceSlider = Section:AddSlider({
    title = "Magnet Distance",
    values = {min = 0, max = 10, default = 0},
    callback = function(set)
        magnetDistance = set
    end,
})

local MagnetPowerSlider = Section:AddSlider({
    title = "Magnet Power",
    values = {min = 0, max = 10, default = 0},
    callback = function(set)
        magnetPower = set
    end,
})

local CatchPercentageSlider = Section:AddSlider({
    title = "Catch %",
    values = {min = 0, max = 100, default = 0},
    callback = function(set)
        catchPercentage = set
    end,
})

local MagnetDelaySlider = Section:AddSlider({
    title = "Magnet Delay",
    values = {min = 0, max = 2, default = 0},
    callback = function(set)
        Delay = set
    end,
})



local player = game.Players.LocalPlayer
local runService = game:GetService("RunService")
local PullVectorEnabled = false
local PullVectorDistance = 10

local function moveBall(ball)
   if ball and player.Character then
       local direction = (ball.Position - player.Character.HumanoidRootPart.Position).Unit
       player.Character.HumanoidRootPart.Velocity = direction * 50  -- Adjust the velocity as desired
   end
end

local function onRunServiceStepped()
   if PullVectorEnabled then
       for _, ball in ipairs(workspace:GetChildren()) do
           if ball.Name == "Football" and ball:IsA("BasePart") then
               local distance = (player.Character.HumanoidRootPart.Position - ball.Position).Magnitude
               if distance < PullVectorDistance then
                   moveBall(ball)
               end
           end
       end
   end
end

local SteppedConnection = nil

local PullVectorToggle = Section:AddToggle({
    title = "Pull Vector",
    desc = "Pull the ball towards you when enabled",
    callback = function(state)
        PullVectorEnabled = state
        if state then
            SteppedConnection = runService.Stepped:Connect(onRunServiceStepped)
        else
            if SteppedConnection then
                SteppedConnection:Disconnect()
            end
        end
    end,
})

local PullVectorDistanceSlider = Section:AddSlider({
    title = "Pull Vector Distance",
    values = {min = 0, max = 50, default = 10},
    callback = function(value)
        PullVectorDistance = value
    end,
})



local maxCatchRange = 15

local hitboxActive = false  -- To track whether hitbox is active

local function createHitbox(football)
    local hitbox = Instance.new("Part")
    hitbox.Size = Vector3.new(30, 20, 30)
    hitbox.Anchored = true
    hitbox.CanCollide = false
    hitbox.Transparency = 0.5
    hitbox.BrickColor = BrickColor.new("Cool grey")
    hitbox.Parent = game.Workspace
    
    local function updateHitboxPosition()
        hitbox.CFrame = CFrame.new(football.Position)
    end
    
    local function playerInRange(player)
        return (player.Character and (player.Character.HumanoidRootPart.Position - football.Position).Magnitude <= maxCatchRange)
    end
    
    local hitboxDestroyTimer = 5
    local startTime = tick()
    
    local connection
    connection = game:GetService("RunService").RenderStepped:Connect(function()
        if hitboxActive then
            updateHitboxPosition()
            
            if tick() - startTime >= hitboxDestroyTimer then
                hitbox:Destroy()
                connection:Disconnect()
            else
                for _, player in pairs(game.Players:GetPlayers()) do
                    if football.IsCaught then
                        break
                    end

                    if playerInRange(player) then
                        print(player.Name .. " is in range to catch the football!")
                    end
                end
            end
        end
    end)
end

local function onFootballAdded(newFootball)
    if hitboxActive and newFootball.Name == "Football" then
        createHitbox(newFootball)
    end
end

game.Workspace.ChildAdded:Connect(onFootballAdded)

local masterToggle = Section:AddToggle({
    title = "Football Hitbox",
    desc = "BigBlackhitbox",
    callback = function(state)
        hitboxActive = state
    end,
})






local Section = MagnetsTwo:AddSeperator("V Catching") do






local LFGCatchingToggle = Section:AddToggle({
    title = "Smooth Catching",
    desc = "Catching very Legit",
    callback = function(state)
        if state then
            local player = game.Players.LocalPlayer
            local rs = game:GetService("RunService")

            function moveBall(ball)
                if ball and player.Character then
                    local leftArm = player.Character:FindFirstChild("Left Arm")
                    if leftArm then
                        ball.CanCollide = true
                        local startPosition = ball.Position
                        local endPosition = leftArm.Position
                        local direction = (endPosition - startPosition).Unit
                        local distance = (endPosition - startPosition).Magnitude
                        local speed = distance / 3000
                        local startTime = tick()

                        rs:BindToRenderStep("MoveBall", Enum.RenderPriority.Camera.Value + 20, function()
                            local elapsedTime = tick() - startTime
                            local t = math.min(elapsedTime / speed, 1)
                            local newPosition = startPosition + direction * distance * t
                            ball.CFrame = CFrame.new(newPosition)
                            if t >= 30 then
                                rs:UnbindFromRenderStep("MoveBall")
                                ball.CanCollide = true
                            end
                        end)
                    end
                end
            end

            rs.Stepped:Connect(function()
                local closestBall = nil
                local closestDist = math.huge

                for _, v in ipairs(workspace:GetChildren()) do
                    if v.Name == "Football" and v:IsA("BasePart") then
                        local mag = (player.Character.Torso.Position - v.Position).Magnitude
                        if mag <= 15 and mag < closestDist then
                            closestBall = v
                            closestDist = mag
                        end
                    end
                end

                if closestBall then
                    moveBall(closestBall)
                end
            end)
        else
            -- You might want to add logic here to stop the movement if necessary
        end
    end,
})


local MagnetPowerSlider = Section:AddSlider({
    title = "blatant Catching",
    values = {min = 0, max = 50, default = 0},
    callback = function(set)
        blatantcatching = set
    end,
})


local MagnetPowerSlider = Section:AddSlider({
    title = "Legit Catching",
    values = {min = 0, max = 50, default = 0},
    callback = function(set)
        Legitcatching = set
    end,
})

local EraMagnets = true
local MaxDistance = 25

local player = game:GetService("Players").LocalPlayer

local function CatchFootball()
    while EraMagnets do
        wait()
        local football = game.Workspace:WaitForChild("Football")
        local humanoid = game.Players.LocalPlayer.Character.HumanoidRootPart

        for index, football in ipairs(workspace:GetChildren()) do
            if football.Name == "Football" and football:IsA("BasePart") and not football.Anchored then
                local mag = (football.Position - humanoid.Position).magnitude
                if mag <= MaxDistance then
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                    wait()
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                end
            end
        end
    end
end

-- Define the master toggle
local masterToggle = Section:AddToggle({
    title = "increase Hands",
    desc = "",
    callback = function(state)
        KiwiMagnets = state
        if KiwiMagnets then
            CatchFootball()
        end
    end,
})

-- Define the slider
local Magnetsslider = Section:AddSlider({
    title = "Hand size",
    values = {min = 1, max = 10, default = 1},
    callback = function(set)
      Magnet = v
    end,
})
local KiwiMagnets = true
local MaxDistance = 23
local MinFootballSize = 5 -- Adjust this value as needed

local player = game:GetService("Players").LocalPlayer

local function CatchFootball()
    while KiwiMagnets do
        wait()
        local football = game.Workspace:WaitForChild("Football")
        local humanoid = game.Players.LocalPlayer.Character.HumanoidRootPart

        for index, football in ipairs(workspace:GetChildren()) do
            if football.Name == "Football" and football:IsA("BasePart") and not football.Anchored then
                local mag = (football.Position - humanoid.Position).magnitude
                local footballSize = football.Size.Magnitude

                if mag <= MaxDistance and footballSize <= MinFootballSize then
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                    wait()
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                end
            end
        end
    end
end


local KiwiMagnets = true
local MaxDistance = 23
local MinFootballSize = 5 -- Adjust this value as needed

local player = game:GetService("Players").LocalPlayer

local function CatchFootball()
    while KiwiMagnets do
        wait()
        local football = game.Workspace:WaitForChild("Football")
        local humanoid = game.Players.LocalPlayer.Character.HumanoidRootPart

        for index, football in ipairs(workspace:GetChildren()) do
            if football.Name == "Football" and football:IsA("BasePart") and not football.Anchored then
                local mag = (football.Position - humanoid.Position).magnitude
                local footballSize = football.Size.Magnitude

                if mag <= MaxDistance and footballSize <= MinFootballSize then
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                    wait()
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                    firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("CatchRight"), football, 0)
                end
            end
        end
    end
end

-- Define the master toggle
local masterToggle = Section:AddToggle({
    title = "increase Football",
    desc = "",
    callback = function(state)
        KiwiMagnets = state
        if KiwiMagnets then
            CatchFootball()
        end
    end,
})

-- Define the slider
local Magnetsslider = Section:AddSlider({
    title = "Football Size",
    values = {min = 1, max = 10, default = 1},
    callback = function(set)
        -- You can use the slider value for catch power if needed
    end,
})



end
end
end

local enabled = false
local autoAngle = false -- Auto Angle
local autoChooseThrowType = false -- Auto Choose Throw Type
local showBeam = false -- Determines if to show the beam projectile
local showCards = false -- Determines if to show cards or not
local throwHeightOffset = 0
local straightenThrowDirection = false -- Determines if to straighten the move direction
local leadDistance = 0 -- Lead Distance (self-explanatory)
local throwData = {
    power = 0,
    direction = Vector3.new(0, 0, 0),
    angle = 40
}

local QbOne, QbTwo = UI:AddTab("Qb", "Passing") do
local Section = QbOne:AddSeperator(" Passing") do
local masterToggle = Section:AddToggle({
title = "Enable QB Aimbot",
desc = "This is a small tip which will appear when the user hovers over this toggle. It works on all elements",
callback = function(state)
local enabled = true
local leadDistance = 5
task.spawn(function()
    --// qb gui initalization
    local gui; do

        local AimCard = Instance.new("ScreenGui")
        local Angle = Instance.new("Frame")
        local AngleCorner = Instance.new("UICorner")
        local AngleNum = Instance.new("TextLabel")
        local NumCorn = Instance.new("UICorner")
        local AngleLabel = Instance.new("TextLabel")
        local LabelCorner = Instance.new("UICorner")
        local Player = Instance.new("Frame")
        local PlayerCorn = Instance.new("UICorner")
        local PlayerText = Instance.new("TextLabel")
        local NumCorn2 = Instance.new("UICorner")
        local PlayerLabel = Instance.new("TextLabel")
        local LabelCorner2 = Instance.new("UICorner")
        local Mode = Instance.new("Frame")
        local Modecorn = Instance.new("UICorner")
        local ModeText = Instance.new("TextLabel")
        local NumCorn3 = Instance.new("UICorner")
        local ModeLabel = Instance.new("TextLabel")
        local LabelCorner3 = Instance.new("UICorner")
        
        -- Properties
        
        AimCard.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
        AimCard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        
        Angle.Name = "Angle"
        Angle.Parent = AimCard
        Angle.BackgroundColor3 = Color3.new(0.156863, 0.156863, 0.156863)
        Angle.BorderColor3 = Color3.new(0, 0, 0)
        Angle.BorderSizePixel = 0
        Angle.Position = UDim2.new(0.110701106, 0, 0.447368413, 0)
        Angle.Size = UDim2.new(0, 100, 0, 100)
        Angle.ZIndex = 7
        
        AngleCorner.Name = "AngleCorner"
        AngleCorner.Parent = Angle
        
        AngleNum.Name = "AngleNum"
        AngleNum.Parent = Angle
        AngleNum.BackgroundColor3 = Color3.new(1, 1, 1)
        AngleNum.BackgroundTransparency = 1
        AngleNum.BorderColor3 = Color3.new(0, 0, 0)
        AngleNum.BorderSizePixel = 0
        AngleNum.Size = UDim2.new(0, 100, 0, 72)
        AngleNum.Font = Enum.Font.Gotham
        AngleNum.Text = "40"
        AngleNum.TextColor3 = Color3.new(1, 1, 1)
        AngleNum.TextScaled = true
        AngleNum.TextSize = 1
        AngleNum.TextWrapped = true
        
        NumCorn.Name = "NumCorn"
        NumCorn.Parent = AngleNum
        
        AngleLabel.Name = "AngleLabel"
        AngleLabel.Parent = Angle
        AngleLabel.BackgroundColor3 = Color3.new(1, 1, 1)
        AngleLabel.BackgroundTransparency = 1
        AngleLabel.BorderColor3 = Color3.new(0, 0, 0)
        AngleLabel.BorderSizePixel = 0
        AngleLabel.Position = UDim2.new(0, 0, 0.660000026, 0)
        AngleLabel.Size = UDim2.new(0, 100, 0, 34)
        AngleLabel.Font = Enum.Font.Gotham
        AngleLabel.Text = "Angle"
        AngleLabel.TextColor3 = Color3.new(0.396078, 1, 0.588235)
        AngleLabel.TextSize = 22
        
        LabelCorner.Name = "LabelCorner"
        LabelCorner.Parent = AngleLabel
        
        Player.Name = "Player"
        Player.Parent = AimCard
        Player.BackgroundColor3 = Color3.new(0.156863, 0.156863, 0.156863)
        Player.BorderColor3 = Color3.new(0, 0, 0)
        Player.BorderSizePixel = 0
        Player.Position = UDim2.new(0.110701106, 0, 0.563157916, 0)
        Player.Size = UDim2.new(0, 100, 0, 100)
        Player.ZIndex = 7
        
        PlayerCorn.Name = "PlayerCorn"
        PlayerCorn.Parent = Player
        
        PlayerText.Name = "PlayerText"
        PlayerText.Parent = Player
        PlayerText.BackgroundColor3 = Color3.new(1, 1, 1)
        PlayerText.BackgroundTransparency = 1
        PlayerText.BorderColor3 = Color3.new(0, 0, 0)
        PlayerText.BorderSizePixel = 0
        PlayerText.Size = UDim2.new(0, 100, 0, 72)
        PlayerText.Font = Enum.Font.Gotham
        PlayerText.Text = "Kiwi"
        PlayerText.TextColor3 = Color3.new(1, 1, 1)
        PlayerText.TextScaled = true
        PlayerText.TextSize = 1
        PlayerText.TextWrapped = true
        
        NumCorn2.Name = "NumCorn2"
        NumCorn2.Parent = PlayerText
        
        PlayerLabel.Name = "PlayerLabel"
        PlayerLabel.Parent = Player
        PlayerLabel.BackgroundColor3 = Color3.new(1, 1, 1)
        PlayerLabel.BackgroundTransparency = 1
        PlayerLabel.BorderColor3 = Color3.new(0, 0, 0)
        PlayerLabel.BorderSizePixel = 0
        PlayerLabel.Position = UDim2.new(0, 0, 0.660000026, 0)
        PlayerLabel.Size = UDim2.new(0, 100, 0, 34)
        PlayerLabel.Font = Enum.Font.Gotham
        PlayerLabel.Text = "Player"
        PlayerLabel.TextColor3 = Color3.new(0.396078, 1, 0.588235)
        PlayerLabel.TextSize = 22
        
        LabelCorner2.Name = "LabelCorner2"
        LabelCorner2.Parent = PlayerLabel
        
        Mode.Name = "Mode"
        Mode.Parent = AimCard
        Mode.BackgroundColor3 = Color3.new(0.156863, 0.156863, 0.156863)
        Mode.BorderColor3 = Color3.new(0, 0, 0)
        Mode.BorderSizePixel = 0
        Mode.Position = UDim2.new(0.110701106, 0, 0.33157894, 0)
        Mode.Size = UDim2.new(0, 100, 0, 100)
        Mode.ZIndex = 7
        
        Modecorn.Name = "Modecorn"
        Modecorn.Parent = Mode
        
        ModeText.Name = "ModeText"
        ModeText.Parent = Mode
        ModeText.BackgroundColor3 = Color3.new(1, 1, 1)
        ModeText.BackgroundTransparency = 1
        ModeText.BorderColor3 = Color3.new(0, 0, 0)
        ModeText.BorderSizePixel = 0
        ModeText.Size = UDim2.new(0, 100, 0, 72)
        ModeText.Font = Enum.Font.Gotham
        ModeText.Text = "Dime"
        ModeText.TextColor3 = Color3.new(1, 1, 1)
        ModeText.TextScaled = true
        ModeText.TextSize = 1
        ModeText.TextWrapped = true
        
        NumCorn3.Name = "NumCorn3"
        NumCorn3.Parent = ModeText
        
        ModeLabel.Name = "ModeLabel"
        ModeLabel.Parent = Mode
        ModeLabel.BackgroundColor3 = Color3.new(1, 1, 1)
        ModeLabel.BackgroundTransparency = 1
        ModeLabel.BorderColor3 = Color3.new(0, 0, 0)
        ModeLabel.BorderSizePixel = 0
        ModeLabel.Position = UDim2.new(0, 0, 0.660000026, 0)
        ModeLabel.Size = UDim2.new(0, 100, 0, 34)
        ModeLabel.Font = Enum.Font.Gotham
        ModeLabel.Text = "Mode"
        ModeLabel.TextColor3 = Color3.new(0.396078, 1, 0.588235)
        ModeLabel.TextSize = 22
        
        LabelCorner3.Name = "LabelCorner3"
        LabelCorner3.Parent = ModeLabel
        
        gui = AimCard
    end
    --// main
    local modes = {
        ["Dime"] = "Bullet",
        ["Bullet"] = "Dime"
    }
    local players = game:GetService("Players")
    local runService = game:GetService("RunService")
    local userInputService = game:GetService("UserInputService")
    local replicatedStorage = game:GetService("ReplicatedStorage")
    local player = players.LocalPlayer
    local angle = 40
    local target = nil
    local locked = false
    local realpower = 0
    local camera = workspace.CurrentCamera
    local highlight = Instance.new("Highlight")
    local sphere = Instance.new("Part")
    local upower, udirection = 0, Vector3.new(0, 0, 0)
    local mouse = loadstring(game:HttpGet("https://raw.githubusercontent.com/vFishyTurtle/UI-Libraries/main/Apple%20Library/a"))()
    local mouseRaycastParams = RaycastParams.new()	
    local usePart = Instance.new("Part")
    usePart.Anchored = true
    usePart.CanCollide = false
    usePart.Size = Vector3.new(2048, 1, 2048)
    usePart.Transparency = 1
    usePart.Parent = workspace
    usePart.Position = player.Character.HumanoidRootPart.Position - Vector3.new(0, 2, 0)
    mouseRaycastParams.FilterType = Enum.RaycastFilterType.Include
    mouseRaycastParams.FilterDescendantsInstances = {usePart}
    mouse:SetRaycastParams(mouseRaycastParams)

    local function getMoveDirection(target)
        if players:GetPlayerFromCharacter(target) then
            return target.Humanoid.MoveDirection
        else
            return (target.Humanoid.WalkToPoint - target.Head.Position).Unit
        end
    end

    local function findPower(pos)
        local powerTable = {
            [10] = 55,
            [20] = 60,
            [30] = 65,
            [35] = 70,
            [40] = 75,
            [50] = 80,
            [60] = 85,
            [70] = 90,
            [80] = 95,
        }
        local distance = (player.Character.Head.Position - pos).Magnitude
        local lDiff = math.huge
        local power = 0
        local pdistance = nil
        local reachedDis = 0
        local nextDis = 0
        local naturalPower = 0
        for dis, pwr in pairs(powerTable) do
            dis *= 3
            if distance > dis and dis > reachedDis then
                power = pwr
                naturalPower = pwr
                pdistance = dis
                reachedDis = dis
                if dis == 90 then nextDis = dis + 15 else nextDis = dis + 30 end
            end
        end
        local diff = math.clamp(nextDis - distance, 0, math.huge)
        local required = (nextDis - reachedDis)
        local nextPower = powerTable[nextDis / 3] or 75
        local percentage = diff / required
        --print(diff, required, nextPower, power, percentage, (nextPower - power) - ((nextPower - power) * percentage))
        power += math.clamp((nextPower - power) - ((nextPower - power) * percentage), 0, 100)
        if power ~= power then
            power = 50
        end
        return power - 5, naturalPower - 5
    end

    local function calculateVelocity(x0, d0, t)
        local g = Vector3.new(0, -28, 0)
        local v0 = (d0 - x0 - 0.5*g*t*t)/t;
        local dir = ((x0 + v0) - x0).Unit
        local power = v0.Y / dir.Y
        return v0, dir, power
    end

    local function findtarget()
        local np = nil
        local nm = math.huge
        local s = {workspace}
        if workspace:FindFirstChild("npcwr") then
            table.insert(s, workspace.npcwr.a)
            table.insert(s, workspace.npcwr.b)
        end
        for i, p in pairs(s) do
            for i, c in pairs(p:GetChildren()) do
                if c:FindFirstChildWhichIsA("Humanoid") and c:FindFirstChild("HumanoidRootPart") then
                    local plr = players:GetPlayerFromCharacter(c)
                    if plr == player then continue end
                    if not plr and game.PlaceId ~= 8206123457 then continue end
                    if not player.Neutral then
                        if plr.Team ~= player.Team then
                            continue
                        end
                    end
                    local d = (c.HumanoidRootPart.Position - mouse.Hit.Position).Magnitude
                    if d < nm then
                        nm = d
                        np = c
                    end	
                end
            end
        end
        return np
    end

    local function methodIsA(self, method)
        return string.lower(self) == string.lower(method)
    end

    local remotes = {Fake = {}}

    local function spoofRemote(remote, funcOnFire)
        local fakeSelf = remote:Clone()
        fakeSelf.Parent = remote.Parent
        remote.Name = ""
        remotes[remote] = funcOnFire
        remotes.Fake[fakeSelf] = remote
    end

    local __namecall; __namecall = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        if methodIsA(method, "FireServer") and not checkcaller() and remotes.Fake[self]  then
            remotes.Fake[self]:FireServer(remotes[remotes.Fake[self]](...))
        end
        return __namecall(self, ...)
    end)

    local function hookFootball(fb)
        local ls = fb.Handle:WaitForChild("LocalScript", 1)
        if ls then
            ls.Enabled = false
            local remoteEvent = fb.Handle:FindFirstChild("RemoteEvent")
            if remoteEvent then
                spoofRemote(remoteEvent, function(old)
                    local args = {old}
                    if args[1] == "Clicked" then
                        if enabled then
                            return unpack({"Clicked", player.Character.Head.Position, player.Character.Head.Position + (udirection * 10000), (game.PlaceId == 8206123457 and upower) or 61, (game.PlaceId ~= 8206123457 and upower) or nil})
                        else
                            local direction = (player:GetMouse().Hit.Position - camera.CFrame.Position).Unit
                            return unpack({"Clicked", player.Character.Head.Position, player.Character.Head.Position + (direction * 10000), (game.PlaceId == 8206123457 and realpower) or 61, realpower})
                        end
                    else
                        return old
                    end
                end)
                fb:WaitForChild("Handle"):WaitForChild("LocalScript").Enabled = true
            end
            ls.Enabled = true
        end
    end

    player.Character.ChildAdded:Connect(function(fb)
        if fb:IsA("Tool") then
            fb:WaitForChild("Handle")
            hookFootball(fb)
        end
    end)

    userInputService.InputBegan:Connect(function(input, gp)
        if not gp then
            if input.KeyCode == Enum.KeyCode.R then
                while userInputService:IsKeyDown(Enum.KeyCode.R) and gui.Mode.ModeText.Text ~= "Bullet"  do
                    angle = angle + 5
                    angle = math.clamp(angle, 5, 90)
                    gui.Angle.AngleNum.Text = angle
                    task.wait(1 / 6)
                end
            elseif input.KeyCode == Enum.KeyCode.F then
                while userInputService:IsKeyDown(Enum.KeyCode.F) and gui.Mode.ModeText.Text ~= "Bullet" do
                    angle = angle - 5
                    angle = math.clamp(angle, 5, 90)
                    gui.Angle.AngleNum.Text = angle
                    task.wait(1 / 6)
                end
            elseif input.KeyCode == Enum.KeyCode.Q then
                locked = not locked
            elseif input.KeyCode == Enum.KeyCode.Z then
                if angle == 15 then
                    angle = 40
                    angle = math.clamp(angle, 5, 90)
                    gui.Angle.AngleNum.Text = angle
                    gui.Mode.ModeText.Text = "Dime"
                    leadDistance = 6
                else
                    angle = 15
                    angle = math.clamp(angle, 15, 15)
                    gui.Angle.AngleNum.Text = angle
                    gui.Mode.ModeText.Text = "Bullet"
                    leadDistance = 10
                end
            end
        end
    end)        

    local function calculateLanding(power, direction)
        local vel = power * direction
        local origin = player.Character.Head.Position + direction * 5
        local peakTime = vel.Y / 28
        return origin + Vector3.new(vel.X * peakTime * 2, 0, vel.Z * peakTime * 2)	
    end

    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = Color3.fromRGB(255, 255, 255)
    line.Thickness = 1

    sphere.Size = Vector3.new(2, 2, 2)
    sphere.Material = Enum.Material.ForceField
    sphere.Anchored = true
    sphere.CanCollide = false
    sphere.Color = Color3.fromRGB(101, 255, 150)
    sphere.Parent = workspace
    highlight.FillColor = Color3.fromRGB(101, 255, 150)

    player.PlayerGui.ChildAdded:Connect(function(child)
        if child.Name == "BallGui" then
            local disp = child:WaitForChild("Frame"):WaitForChild("Disp")
            disp.Changed:Connect(function()
                realpower = tonumber(disp.Text)
            end)
        end
    end)
 
    while true do
        runService.RenderStepped:Wait()
        pcall(function()
            if not locked then
                target = findtarget()
            end
            gui.Enabled = player.PlayerGui:FindFirstChild("BallGui") and enabled
            if target and enabled and player.PlayerGui:FindFirstChild("BallGui") then
                local position, onScreen = workspace.CurrentCamera:WorldToViewportPoint(target.HumanoidRootPart.Position)
                local power = findPower(target.Head.Position)
                local moveDirection = getMoveDirection(target)
                local assumedDirection = (target.Head.Position - player.Character.Head.Position).Unit
                local speed = (assumedDirection * power).Magnitude
                local t = ((target.Head.Position - player.Character.Head.Position).Magnitude / speed) * (angle / 22)
                local velocity, dir, pwr = calculateVelocity(player.Character.Head.Position + assumedDirection * 5, target.Head.Position + (moveDirection * 20 * t) + moveDirection * leadDistance, t)
                highlight.Parent = target
                upower = math.clamp(pwr, 0, 95)
                udirection = dir
                sphere.Transparency = 0
                gui.Player.PlayerText.Text = target.Name
                sphere.Position = calculateLanding(upower, udirection)
                if onScreen then
                    line.Visible = false
                    line.From = workspace.CurrentCamera:WorldToViewportPoint(player.Character.Football.Handle.Position)
                    line.To = Vector2.new(position.X, position.Y)
                else
                    line.Visible = false
                end
            else
                line.Visible = false
                highlight.Parent = nil
                sphere.Transparency = 1
            end
        end)
    end
end)
end
})







local AutoQBToggle = Section:AddToggle({
    title = "Auto QB",
    callback = function(data)
        local blacklisted = {"KICKOFF", "PUNT", "PAT"}
        while true do
            task.wait(1/30)
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and replicatedStorage.Values:FindFirstChild("Status") and replicatedStorage.Values.Status.Value == "PrePlay" and workspace:FindFirstChild("Football") and data.Enabled and not table.find(blacklisted, replicatedStorage.Values.StatusTag.Value) and replicatedStorage.Values.PossessionTag.Value == player.Team.Name then
                player.Character.HumanoidRootPart.CFrame = workspace:FindFirstChild("Football").CFrame
                repeat task.wait() until not workspace:FindFirstChild("Football")
            end
        end
    end
})


local masterToggle = Section:AddToggle({
title = "auto angle",
desc = "This is a small tip which will appear when the user hovers over this toggle. It works on all elements",
callback = function(state)
autoAngle = v
end
})



local masterToggle = Section:AddToggle({
title = "anti OOB",
desc = "This is a small tip which will appear when the user hovers over this toggle. It works on all elements",
callback = function(state)
straightenThrowDirection = v
end
})






local Qbslider = Section:AddSlider({
title = " Lead Distance",
values = {min=0,max=50,default=0},
callback = function(set)
leadDistance = v
end,
})






local Qbslider = Section:AddSlider({
title = "Pass Height",
values = {min=0,max=5.3,default=0},
callback = function(set)
PassHeight = v
end,
})


local Qbslider = Section:AddSlider({
title = "Catching Chance",
values = {min=0,max=5.3,default=0},
callback = function(set)
CatchingChance = v
end,
})


local slider = Section:AddSlider({
title = "Perfect dime chance",
values = {min=0,max=3,default=0},
callback = function(set)
PerfectDimeChance = v
end,
})

local Section = QbTwo:AddSeperator("Kicking") do
local autokick = false

task.spawn(function()
    getgenv().Variables = {}

    Variables.Players = game:GetService("Players")
    Variables.ReplicatedStorage = game:GetService("ReplicatedStorage")
    Variables.UserInputService = game:GetService("UserInputService")
    Variables.Client = Variables.Players.LocalPlayer
    Variables.Character = Variables.Client.Character or Variables.Client.CharacterAdded:Wait()

    Variables.Client.CharacterAdded:Connect(function(Character)
        Variables.Character = Character
    end)

    local Aimbot = {}

    function Aimbot:GetAccuracyArrow(Arrows)
        local Y = 0
        local Arrow1 = nil

        for _, Arrow in pairs(Arrows) do
            if Arrow.Position.Y.Scale > Y then
                Y = Arrow.Position.Y.Scale
                Arrow1 = Arrow
            end
        end

        return Arrow1
    end

    Variables.Client.PlayerGui.ChildAdded:Connect(function(child)
        if child.Name == "KickerGui" and autokick == true then
            local KickerGui = child
            local Meter = KickerGui:FindFirstChild("Meter")
            local Cursor = Meter:FindFirstChild("Cursor")
            local Arrows = {}

            for i, v in pairs(Meter:GetChildren()) do
                if string.find(v.Name:lower(), "arrow") then
                    table.insert(Arrows, v)
                end
            end

            repeat
                task.wait()
            until Cursor.Position.Y.Scale < 0.02
            mouse1click()
            repeat
                task.wait()
            until Cursor.Position.Y.Scale >= Aimbot:GetAccuracyArrow(Arrows).Position.Y.Scale + (.03 / (100 / 100))
            mouse1click()
        end
    end)
end)

local masterToggle = Section:AddToggle({
    title = "Kicker aimbot",
    desc = "Catching football for GAY KIDS",
    callback = function(state)
        autokick = state
    end
})

local slider = Section:AddSlider({
    title = "Kicking Accuracy",
    values = { min = 0, max = 3, default = 0 },
    callback = function(value)
        PerfectKick = v
    end
})






end
end
end


local PhyOne, PhyTwo = UI:AddTab("Physics", "Misc") do
local Section = PhyOne:AddSeperator("Misc") do





local player = game.Players.LocalPlayer
local character = player.Character
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local collisionEnabled = true

local function setCharacterCollision(enabled)
    for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            for _, part in ipairs(otherPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = enabled
                end
            end
        end
    end
end

local function checkProximity()
    while collisionEnabled do
        wait(0.1)
        local characters = workspace:GetChildren()
        for _, otherCharacter in ipairs(characters) do
            if otherCharacter:IsA("Model") and otherCharacter:FindFirstChild("HumanoidRootPart") then
                local distance = (humanoidRootPart.Position - otherCharacter.HumanoidRootPart.Position).magnitude
                if distance <= 5 then
                    setCharacterCollision(false)
                    wait(2)
                    setCharacterCollision(true)
                end
            end
        end
    end
end

local toggleValue = false

local masterToggle = Section:AddToggle({
    title = "Anti Jam",
    desc = "Makes you not get Jammed",
    callback = function(state)
        toggleValue = state
        collisionEnabled = state
        if state then
            checkProximity()
        end
    end,
})



local masterToggle = Section:AddToggle({
title = "Anti Lag",
desc = "",
callback = function(state)
if game:GetService("Workspace"):FindFirstChild("Parts") then
   game:GetService("Workspace"):FindFirstChild("Parts"):Destroy()
   end
end
})
    
    
-- Define the functions for Auto Swat
local autoswatv = 0
local enabledd = false
local connection

local function autoswatfunction()
    if enabledd then
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        local RunService = game:GetService("RunService")

        local function checkDistance(part)
            local distance = (part.Position - humanoidRootPart.Position).Magnitude
            if distance <= autoswatv then
                keypress(0x52) -- Press 'R' key
                keyrelease(0x52) -- Release 'R' key
                task.wait()
            end
        end
        
        local function updateDistances()
            for _, v in pairs(game.Workspace:GetDescendants()) do
                if v.Name == "Football" and v:IsA("BasePart") then
                    checkDistance(v)
                end
            end
        end
        
        connection = RunService.Heartbeat:Connect(updateDistances)
    else
        if connection then
            connection:Disconnect()
            connection = nil
        end
    end
end

local player = game.Players.LocalPlayer
local eventConnection -- To keep track of the connection

local function handleBall(ball)
    if ball.Name == "Football" and ball:IsA("BasePart") then
        local v0 = ball.Velocity
        local x0 = ball.Position
        local dt = 1/30
        local grav = Vector3.new(0, -28, 0)
        local points = {
            [1] = x0
        }
        local function check(p, v0)
            local raycastParams = RaycastParams.new()
            raycastParams.RespectCanCollide = true
            local ray = workspace:Raycast(p, Vector3.new(0, -1000, 0), raycastParams)
            local ray2 = workspace:Raycast(p, Vector3.new(0, -7.2 * 2, 0), raycastParams)
            return ray and not ray2
        end
        while true do
            if not check(points[#points], v0) then
                if v0.Y < 0 then
                    break
                end
            end
            local currentPoint = points[#points]
            v0 = v0 + grav * dt
            points[#points + 1] = currentPoint + (v0 * dt)
        end
        local optimal = points[#points]
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Position = Vector3.new(optimal.X, player.Character.HumanoidRootPart.Position.Y + 1.5, optimal.Z)
        part.Parent = workspace
        part.Material = Enum.Material.Neon
        part.Size = Vector3.new(1.5, 1.5, 1.5)
        repeat task.wait() until ball.Parent ~= workspace
        part:Destroy()
    end
end

local function handleChildAdded(ball)
    task.wait()
    handleBall(ball)
end

local function toggleCallback(state)
    if state then
        eventConnection = workspace.ChildAdded:Connect(handleChildAdded)
    else
        if eventConnection then
            eventConnection:Disconnect()
            eventConnection = nil
        end
    end
end

local localToggle = Section:AddToggle({
    title = "Optimal Jump locations",
    desc = "Teleports you to the nearest player when you click Mouse Button 1",
    callback = toggleCallback,
})



-- Create the "Auto Swat" toggle
local ToggleAutoSwat = Section:AddToggle({
    title = "Auto Swat",
    desc = "Automatically swat the ball when within range",
    callback = function(value)
        enabledd = value
        autoswatfunction()
    end
})

-- Create the "Auto Swat Range" slider
local SliderAutoSwatRange = Section:AddSlider({
    title = "Auto Swat Range",
    min = 0.1,
    max = 45,
    value = 0,
    callback = function(value)
        autoswatv = value
    end
})



local UserInputService = game:GetService("UserInputService")
local TeleportToNearestPlayerEnabled = false

local function GetNearestPlayer()
    local player = game.Players.LocalPlayer
    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not humanoidRootPart then
        return nil
    end

    local nearestPlayer = nil
    local nearestDistance = math.huge

    for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player then
            local otherCharacter = otherPlayer.Character
            local otherHumanoidRootPart = otherCharacter and otherCharacter:FindFirstChild("HumanoidRootPart")

            if otherHumanoidRootPart then
                local distance = (otherHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude

                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end

    return nearestPlayer
end

local TeleportToNearestPlayerToggle = Section:AddToggle({
    title = "Auto Click Aimbot",
    desc = "Teleports you to the nearest player when you click Mouse Button 1",
    callback = function(state)
        TeleportToNearestPlayerEnabled = state
    end,
})

UserInputService.InputBegan:Connect(function(input, _)
    if TeleportToNearestPlayerEnabled and input.UserInputType == Enum.UserInputType.MouseButton1 then
        local nearestPlayer = GetNearestPlayer()

        if nearestPlayer then
            local character = nearestPlayer.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

            if humanoidRootPart then
                local playerCharacter = game.Players.LocalPlayer.Character
                local playerHumanoidRootPart = playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart")

                if playerHumanoidRootPart then
                    playerHumanoidRootPart.CFrame = humanoidRootPart.CFrame
                end
            end
        end
    end
end)

        local slider = Section:AddSlider({
title = "Auto click Size",
values = {min=0,max=30 ,default=0},
callback = function(set)

end,
})




local AutoFollowQb = false
local followCarrierTask

local function FollowCarrier()
    while AutoFollowQb do
        local carrier = game:GetService("ReplicatedStorage").Values.Carrier.Value
        if carrier and carrier:IsDescendantOf(game.Players) and carrier.Team ~= game.Players.LocalPlayer.Team then
            local humanoid = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid:MoveTo(carrier.Character.Torso.Position)
            end
        end
        wait()
    end
end

local function ToggleFollowCarrier(value)
    AutoFollowQb = value
    if value then
        followCarrierTask = task.spawn(FollowCarrier)
    else
        if followCarrierTask then
            followCarrierTask:cancel()
        end
    end
end

local masterToggle = Section:AddToggle({
    title = "Auto follow",
    desc = "Tackle",
    callback = ToggleFollowCarrier,
})



      local slider = Section:AddSlider({
title = "Auto Follow Distance",
values = {min=0,max=30 ,default=0},
callback = function(set)

end,
})




local Section = PhyTwo:AddSeperator("Player") do






  local function toggleState(v)
        local state = v
        local transparency = state and 0.5 or 0
        local model = game:GetService("Workspace").Models.Field.Grass
        
        for _, part in pairs(model:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = not state
                part.Transparency = transparency
            end
        end
        
        if state then
            local part = Instance.new("Part")
            part.Size = Vector3.new(500, 0.001, 500)
            part.CFrame = CFrame.new(Vector3.new(10.3562937, -1.51527438, 30.4708614))
            part.Anchored = true
            part.Parent = game.Workspace
        
            local Anim = Instance.new("Animation")
            Anim.AnimationId = "rbxassetid://"
            local track = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(Anim)
            track:Play(.1, 1, 1)
        else
            if track ~= nil then
                track:Stop()
            end
        end
    end
    
    local undergroundToggle = Section:AddToggle({
        title = "Underground Enabled",
        desc = "This is a small tip which will appear when the user hovers over this toggle. It works on all elements",
        callback = function(v)
            toggleState(v)
        end
    })




local masterToggle = Section:AddToggle({
    title = "Anti-OOB",
    desc = "Lets You Go Out Of Bounds With Ball",
    callback = function(state)
        getgenv().Shit = state
    end,
})

local autoCaptainToggle = Section:AddToggle({
    title = "Auto-Captain",
    desc = "Free Auto-Captain",
    callback = function(state)
        getgenv().Captain = state
    end,
})




local walkspeedToggle = Section:AddToggle({
    title = "Walkspeed Enable",
    desc = "Enables Walkspeed",
    callback = function(state)
        getgenv().Walkspeed = state
        while getgenv().Walkspeed == true do
            game:GetService("Players").LocalPlayer.Character.Humanoid.WalkSpeed = _G.SPEED
            wait()
        end
        if getgenv().Walkspeed == false then
            game:GetService("Players").LocalPlayer.Character.Humanoid.WalkSpeed = 20
        end
    end,
})

local jpToggle = Section:AddToggle({
    title = "JP Enable",
    desc = "Enables Jump Power",
    callback = function(state)
        getgenv().JP = state
        while getgenv().JP == true do
            game:GetService("Players").LocalPlayer.Character.Humanoid.JumpPower = _G.Jump
            wait()
        end
        if getgenv().JP == false then
            game:GetService("Players").LocalPlayer.Character.Humanoid.JumpPower = 50
        end
    end,
})



local walkspeedSlider = Section:AddSlider({
    title = "Walkspeed",
    values = {min = 25, max = 45, default = 45},
    callback = function(value)
        _G.SPEED = value
    end,
})

local jpSlider = Section:AddSlider({
    title = "JP",
    values = {min = 60, max = 82, default = 82},
    callback = function(value)
        _G.Jump = value
    end,
})

local RunService = game:GetService("RunService")
local KickoffMovementToggle
local originalWalkSpeed = 16  -- Adjust this to your desired walk speed

local function AdjustWalkSpeed()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        local humanoid = character.Humanoid
        if KickoffMovementToggle and KickoffMovementToggle.getToggled() then
            humanoid.WalkSpeed = originalWalkSpeed
        else
            humanoid.WalkSpeed = 0  -- Set to 0 to prevent movement
        end
    end
end



end
end
end
